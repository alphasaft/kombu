
# -*- coding: utf-8 -*-
# This code was generated by the KomBu compiler.
# (C) Morel Hugo


from Parsing.BaseParser import BaseParser
from utils import rule, get_time


class LightParser(BaseParser):
	def __init__(self):
		BaseParser.__init__(self)

	def parse(self, src):
		self.src = src
		self._init_configs()
		self._init_properties(
			libspath='. ; kblibs',
			keep_whitespaces=False,
			cut_end=False,
			get_time=True,
			show_ast=True,
         )
		# Call of the axiom rule
		self._code_(name='self')
		return self._end_of_parsing()

	@rule()
	def _code_(self):
		self._line_(name='self')
		self._match(';')
		self._regex_match('(\n)*')
		with self._optional(name='self'):
			self._code_(name='self')

	@rule()
	def _line_(self):
		with self._choices(name='self'):

			with self._option():
				self._displaying_(name='+instrs')

			with self._option():
				self._var_declaration_(name='+instrs')

	@rule()
	def _instructions__baseValue_(self):
		with self._choices(name='self'):

			with self._option():
				self._instructions__ident_(name='value')
			print(self._choices_groups_possibles_asts[-1])

			with self._option():
				self._instructions__int_(name='value')

			with self._option():
				self._instructions__string_(name='value')

			with self._option():
				self._instructions__float_(name='value')

	@rule()
	def _instructions__ident_(self):
		self._instructions__basics__ident_(name='self')

	@rule()
	def _instructions__basics__ident_(self):
		self._regex_match('[a-zA-Z_][a-zA-Z_0-9]*')

	@rule()
	def _instructions__int_(self):
		self._instructions__basics__int_(name='self')

	@rule()
	def _instructions__basics__int_(self):
		print("begin")
		self._regex_match('[0-9]+')
		if self._ast: print("success")
		print("end")

	@rule()
	def _instructions__float_(self):
		self._instructions__basics__float_(name='self')

	@rule()
	def _instructions__basics__float_(self):
		print("begin2")
		with self._optional(name='self'):
			self._match('-')
		self._regex_match('[0-9A]+')
		self._match('rjlykhnoitrkl.')
		self._regex_match('[0-9A]+')
		print("end2")

	@rule()
	def _instructions__basics__SQS_(self):
		self._regex_match('\'[^\']*?\'')

	@rule()
	def _instructions__basics__DQS_(self):
		self._regex_match('"[^"]*?"')

	@rule()
	def _instructions__string_(self):
		self._instructions__basics__string_(name='self')

	@rule()
	def _instructions__basics__string_(self):
		with self._choices(name='self'):

			with self._option():
				self._instructions__basics__SQS_()

			with self._option():
				self._instructions__basics__DQS_()

	@rule()
	def _displaying_(self):
		self._instructions__displaying_(name='self')

	@rule()
	def _instructions__displaying_(self):
		self._match('display')
		self._instructions__baseValue_(name='value')

	@rule()
	def _var_declaration_(self):
		self._instructions__var_declaration_(name='self')

	@rule()
	def _instructions__var_declaration_(self):
		self._match('test2')



class LightNodeWalker:
	def __init__(self):
		self.variables={}
		print (' -- begin -- ')
		print ()

	def _inspect(self, ast):
		try:
			ast.type
		except AttributeError:
			raise SyntaxError('Can only use "node" keyword on AST objects')
		return getattr(self, '_'+ast.type+'_')(ast)

	def walk(self, ast):
		print('Got AST :', ast)
		try:
			self._code_(ast)
			self.end()
		except IndexError:
			print("/!\ : AST wasn't evaluated.")
			return ast
	def end(self):
		print ()
		print (' -- end -- ')
		print ()


	def _code_(self, ast):
		for instr in ast .instrs :
		                self._inspect(instr)
		

	def _instructions__baseValue_(self, ast):
		return self._inspect(ast.value)

	def _instructions__ident_(self, ast):
		return self.variables[ast .get ()]

	def _instructions__int_(self, ast):
		return int (ast .get ())

	def _instructions__float_(self, ast):
		return float (ast .get ())

	def _instructions__string_(self, ast):
		return ast .get ()[1:-1]

	def _displaying_(self, ast):
		return print (ast .type )

	def _var_declaration_(self, ast):
		return None 



class LightCompiler:
	def __init__(self, parsing=LightParser, semantics=LightNodeWalker):
		self._parsing, self._semantics = parsing(), semantics()

	@get_time
	def compile(self, src):
		ast = self._parsing.parse(src)
		return self._semantics.walk(ast)


compiler = LightCompiler()
compiler.compile("display 1 ;\n")
