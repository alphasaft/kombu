# -*- coding=utf-8 -*-

from KomBuInterpreter.KomBuChecker import KomBuChecker
from KomBuInterpreter.Kompilers.KomBuParserKompiler import KomBuParserKompiler
from KomBuInterpreter.Kompilers.KomBuSemanticsKompiler import KomBuSemanticsKompiler
from KomBuInterpreter.Kompilers.KomBuErrorCatcherKompiler import KomBuErrorCatcherKompiler
from KomBuInterpreter.Kompilers.BaseKompiler import BaseKompiler
from KomBuInterpreter.TokenClasses import *
from utils import escape_quotes
from re import sub


TEMPLATE = """
# -*- coding=utf-8 -*-
# This code was generated by the KomBu compiler, and cannot work without the kombu library.
# KomBu Copyright (C) 2020 Morel Hugo

import sys
del sys.path[7:]
sys.path.append('/home/louise/PycharmProjects/KomBu-v1.0')

from Parsing.BaseParser import BaseParser
from exceptions import RaisedError
from utils import rule, warning, error
from debug import get_time


{0}


{1}


{2}

class {3}Compiler:
    def __init__(self, parsing={3}Parsing, semantics={3}NodeWalker, catcher={3}ErrorCatcher):
        self._parsing, self._semantics, self._error_catcher = parsing(), semantics(), catcher()
    {4}
    def compile(self, src):
        try:
            ast, warnings = self._parsing.parse(src)
        except Exception as e:
            raise self._error_catcher.catch(e)
        else:
            for w in warnings:
                print(self._error_catcher.warn(w))

            return self._semantics.walk(ast)
    

if __name__ == '__main__':
    SRC = \"\"\"[insert input here]\"\"\" # input
    myCompiler = {3}Compiler()
    myCompiler.compile(SRC)
    
"""


class KomBuKompiler(BaseKompiler):
    def __init__(self, semantics_kompiler=KomBuSemanticsKompiler, parsing_kompiler=KomBuParserKompiler, error_catcher_kompiler=KomBuErrorCatcherKompiler):
        BaseKompiler.__init__(self)
        self._parsing_kompiler = parsing_kompiler()
        self._semantics_kompiler = semantics_kompiler()
        self._error_catcher_kompiler = error_catcher_kompiler()
        self._ast = []

    def kompile(self, src, base_filepath, filename):
        # We split the semantics and the the parsing part and kompile it.

        self._ast = self._checker.check(src, base_filepath, filename).ast
        semantics = [i for i in self._ast if type(i) in [UnilineInspection, MultilineInspection, BeforeBlock, AfterBlock]]
        catchers = [i for i in self._ast if type(i) in [ErrorCatcher, WarningCatcher]]
        parsing = [i for i in self._ast if type(i) not in [UnilineInspection, MultilineInspection, BeforeBlock, AfterBlock, ErrorCatcher, WarningCatcher]]

        compiled_parser_code, raw_properties = self._parsing_kompiler.compile(parsing)
        compiled_semantics_code = self._semantics_kompiler.compile(semantics)
        compiled_catchers_code = self._error_catcher_kompiler.compile(catchers)

        properties = ""
        for k, v in raw_properties.items():
            if not k in ['name' 'get_time', 'axiom']:
                properties += "\t\t" + k + "=" + ("'"+escape_quotes(v)+"'" if type(v) is str else str(v)) + ",\n"

        c = TEMPLATE.format(
            compiled_parser_code,
            compiled_semantics_code,
            compiled_catchers_code,
            raw_properties['name'],
            "\n    @get_time" if raw_properties["get_time"] else ""
        )

        c = c.format(
            raw_properties['name'],
            filename[:-3]+'__'+raw_properties['axiom'],
            properties,
            "@get_time" if raw_properties["get_time"] else "",
            "print('Got ast :', ast)" if raw_properties["show_ast"] else "",
            self._semantics_kompiler.compile_initialization(),
            self._semantics_kompiler.compile_end(),
            self._error_catcher_kompiler.warnings-1,
            self._error_catcher_kompiler.errors-1
        )

        c = c.replace('<LCB>', '{').replace('<RCB>', '}')

        return c, raw_properties
